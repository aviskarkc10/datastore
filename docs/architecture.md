# Architecture

An outline of the Verida Datastore architecture and design decisions.

## Design Principles

Verida Datastore is designed with the following principles:

- Security must not be compromised
- Put the user first
- Use existing standards where possible
- Embrace open source software principles
- Suitable for Enterprise use
- Maximise data portability
- Write data once, access everywhere
- Blockchain agnostic where possible
- Streamline on-boarding for users and developers

The rest of this Architecture document provides an overview of the key design decisions and features.

?> The Verida Datastore is in active development, so some of these capabilities are not yet implemented.

## System Design

<div>
  <div><img src="images/Personal Data Store v1.png" style="width: 75%" /></div>
  <div><caption>Personal Data Store - System Architecture</caption></div>
</div>

The Verida Data Store is basically a per user database that exists within your application. It manages syncronising data between your application and the Datastore within the user's Verida Vault. This is akin to the user's **master database**. Once data is synced with the user's Vault, it is synced with all other applications attached to the user's Vault based on the data schemas and permissions of that application.

This ensures data entered into one application is automatically made available to all other applications.

?> For example: A user may add a new contact to their `social/contact` schema in an email client. That contact will then automatically appear in their phone contact list and any other applications that have an embedded Verida Data Store into their application.

## Security

Security is built into the core of the architecture, providing for many different ways data can be secured:

- **Private data:** Only the user can read and write (ie: Birth certificate document)
- **Public read and write:** Any user can read and write data (ie: Public comment thread)
- **Public read and restricted write:** Only the user can write, but the public can read data (ie: Public blog)
- **Restricted read and restricted write:** Only an approved list of users can read and write (ie: Private group chat)

All non-public data is encrypted using keys only accessible by the user(s) who have access to that particular data.

## Identity

Users are identified using a [decentralised identifier (DID)](https://w3c.github.io/did-core/). These are basically blockchain addresses (ie: `0xf3beac30c498d9e26865f34fcaa57dbb935b0d74`) that are known to be controlled by the user.

A user identifies themselves by providing their blockchain address in the DID format that also specifies the blockchain being used.

ie: `did:ethr:0xf3beac30c498d9e26865f34fcaa57dbb935b0d74`

## Authorization

A user authorizes an application by signing a known message using their blockchain wallet.

An application making a request to the `datastore.connect()` method in the Verida Datastore will cause a popup appear asking the user to sign a message `Do you approve access to view and update "My Application Name"?`.

This signed message is then used as a synchronous encryption key to unlock the users encryption keys for the current application.

!> For enhanced security, the per-application encryption keys are not stored anywhere. They can only be generated by a user signing the exact same message using their on chain address.

## Databases

Data is stored in both the user's Verida Vault (akin to their `master` database) and an `application` specific database. These two database are then kept in sync &mdash; *See Data Synchronisation (below)*

### User's Vault Database

Each user has a `master` Verida Vault that contains all their data. This can be accessed by logging into https://vault.alpha.verida.io/. This data is encrypted (unless marked as `public`) by encryption keys specific for this master database that can only be unlocked when a user signs a consent message (See _Authorization_ above).

### User's Application Databases

Applications have separate user databases. This data is encrypted (unless marked as `public`) by encryption keys specific for the application. This data can be unlocked when a user access the application or when a user accesses their Verida Vault.

### User's Inbox

All users have a public data `inbox` that can be accessed from their Verida Vault. Any application can send any type of valid schema data to this inbox which the user can then choose to accept or deny. A user could be sent a digital receipt, identity document or a simple message.

Applications can easily send data to a user with the `app.inbox.send(did, message)` method. The message is converted into a digitally signed DID-JWT object and then encrypted using the User's wallet public key. When a user opens the Verida Vault application, the data in their inbox is decrypted using their private key and the DID-JWT is decoded. This decrypted and decoded data is then saved as an encrypted message in the users private inbox and shown to the user.

In addition, every application has it's own inbox.

### Data Storage

Under the hood a combination of [CouchDB](https://en.wikipedia.org/wiki/Apache_CouchDB) and [PouchDB](https://pouchdb.com/) is used to store user data. Here's why that combination was chosen over other options:

- CouchDB was released in 2005. It is well supported and battle hardened over the years. This meets the principle: `Suitable for Enterprise use`.
- CouchDB supports multi-master replication and multi-version concurrency control (MVCCC) making it ideally suited to synchronise data between applications. This meets the principle: `Write once, use everywhere`.
- CouchDB supports custom user permissions. This meets the principle: `Security must not be compromised`.
- PouchDB is a Javascript implementation of CouchDB that can run within a web browser (or mobile app) enabling user data to be encrypted within the web browser before being sent to CouchDB, while still enabling full database query support of the encrypted data. This meets the principles: `Security must not be compromised` and helps on-board new developers by providing well known query capabilities.

At the end of the day, data must be physically stored somewhere. Verida Datastore is designed to empower user's to control where their data is stored. This meets the principle: `Put the user first`.

### Hosting

Verida currently provides infrastructure for storing user's master database and application databases. In the future, this will be opened up for any user or application developer to host their own data (or use third party hosting providers).

This meets the principle: `Streamline on-boarding for users and developers`.

## Data Schemas

While data is stored in a NoSQL database, the architecture is designed to support [JSON Schema](https://json-schema.org/) definitions. This enables:

- Data of a particular type created in one application can be used in another application (ie: A user's Contact list can be shared across multiple communication apps)
- Data can be validated before storing in the user's database
- Data can be queried in a consistent way
- Data can be grouped together by type, enabling permissioned sharing between apps

Verida Datastore provides a set of base / shared schemas for interoperability between applications.

Application developers can contribute to the base schemas or develop their own private schemas.

?> For maximum flexibility, an application can create custom user databases to store any schema-less data specific for the application.

## Data Synchronisation

Applications built with Verida Datastore store user data in two places; The user's master database **and** a user's application database.

This is done to ensure security of user's data as it prevents applications directly accessing a user's master database. Each application has separate encryption keys for enhanced security.

When a user logs into their Verida Vault it automaticall performs the following operations in the background:

- Decrypt any new application data
- Re-encrypt any new application data and store it in the user's `master` Verida Vault database

This synchronisation process is facilitated via the CouchDB replication protocol. Data from multiple applications using the same schemas can be synchronised into a single user master database with minimal conflicts. This is very similar to a `git merge` for the user's application databases. This process also works in reverse &mdash; relevant data from a user's master database is synchronised with the user's application databases.

When a user connects to an application for the first time, the application will send an encrypted message to the user's public inbox, providing information about the new application. This includes details of the database cluster(s) where the application data can be found and any permission requests for syncing user's master data with the application. The user then saves this information to their master database in a list of applications where data can be synchronised.

## Data Querying

The majority of solutions in this space provide simple `key` / `value` storage options as querying encrypted databases is a significantly _hard_ problem.

The Verida Data Store architecture has the following features that facilitate querying of encrypted data in a consistent manner across many distributed databases:

- Using `CouchDB`compatible database syncronisation and merging
- Using common JSON schemas to ensure data consistency between distributed applications
- Encrypt / Decrypt data on the fly between multiple `CouchDB` compliant database backends, with different encryption keys for each

As a result, all applications implementing the Verida Datastore support querying user data as you would expect from a typical NoSQL database.

Example: Fetch all runs a user has completed in 2018

```
let employmentData = myApp.getMany("health/activity", {
  type: "run",
  date: {
    "$gte": "2018-01-01"
  }
});
```